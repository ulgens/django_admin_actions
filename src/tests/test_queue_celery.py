import pytest
from django.contrib.admin.helpers import ACTION_CHECKBOX_NAME

from admin_actions.actions.queue_celery import QueueCeleryAction
from tests._app.models import AdminActionsTestModel


def test_generated_action_is_registrable(admin, rf, celery_task, admin_user):
    """
    The Admin should have an action calling `queue_action`.
    The action is generated by QueueCeleryAction.
    """

    r = rf.get("/")
    r.user = admin_user

    queue_action = QueueCeleryAction(task=celery_task)
    admin.actions += (queue_action,)

    actions = admin.get_actions(r)
    expected = "tests.conftest.sample_task"  # Generated from the celery_task fixture
    assert expected in actions.keys(), (
        f"Expected action '{expected}' not found in admin actions."
    )
    assert actions[expected][0] is queue_action


def test_generated_action_is_nameable(admin, rf, celery_task, admin_user):
    """QueueCeleryAction should accept a custom name."""
    r = rf.get("/")
    r.user = admin_user

    queue_action = QueueCeleryAction(task=celery_task, name="custom_action_name")
    admin.actions += (queue_action,)

    actions = admin.get_actions(r)
    expected = "custom_action_name"  # Generated from the task
    assert expected in actions.keys(), (
        f"Expected action '{expected}' not found in admin actions."
    )
    assert actions[expected][0] is queue_action


@pytest.mark.django_db
def test_generated_action_is_callable(
    admin,
    mocked_task,
    celery_task,
    model_instance,
    _request,
):
    """The Admin should have a sample_task action"""
    instance = model_instance()
    r = _request("post", data={ACTION_CHECKBOX_NAME: [instance.pk]})

    queue_action = QueueCeleryAction(task=celery_task)
    queue_action(admin, r, AdminActionsTestModel.objects.filter(pk=instance.pk))

    mocked_task.assert_called_once_with(instance.pk)


@pytest.mark.django_db
def test_condition_failure_excludes_records(
    admin,
    mocked_task,
    celery_task,
    model_instance,
    _request,
):
    """The Admin should have a sample_task action"""
    instance = model_instance()
    r = _request("post", data={ACTION_CHECKBOX_NAME: [instance.pk]})

    queue_action = QueueCeleryAction(task=celery_task, condition=lambda _: False)
    queue_action(admin, r, AdminActionsTestModel.objects.all())

    # Every record was rejected, task should never be delayed
    mocked_task.assert_not_called()


@pytest.mark.django_db
def test_condition_result_determines_record_inclusion(
    admin,
    mocked_task,
    celery_task,
    model_instance,
    _request,
):
    """The condition should include and exclude appropriately."""
    instance = model_instance()
    r = _request("post", data={ACTION_CHECKBOX_NAME: [instance.pk]})
    model_instance()  # A second instance that should be excluded

    def condition(record):
        return record.pk == instance.pk

    queue_action = QueueCeleryAction(task=celery_task, condition=condition)
    queue_action(admin, r, AdminActionsTestModel.objects.all())

    # The record met the condition, task should be delayed
    mocked_task.assert_called_once_with(instance.pk)


def test_noncallable_condition_raises(celery_task):
    """Providing a non-callable condition should raise an error."""
    with pytest.raises(TypeError):
        QueueCeleryAction(task=celery_task, condition="not_a_function")  # pyright: ignore[reportArgumentType]


def test_noncallable_task_raises():
    """Providing a non-callable task should raise an error."""
    with pytest.raises(TypeError):
        QueueCeleryAction(task="not_a_function")  # pyright: ignore[reportArgumentType]
